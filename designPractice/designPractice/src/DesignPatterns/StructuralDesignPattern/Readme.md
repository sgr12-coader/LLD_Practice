# Structural Design Patterns

The Structural Design Patterns are a family of design patterns that deal with how classes and objects are composed to form larger structures. They focus on improving the flexibility, reusability, and maintainability of your code by providing mechanisms for organizing and combining objects.

## Key Characteristics:

* Object Composition: These patterns often involve combining objects in different ways to create more complex structures.
* Flexibility: They make your code more adaptable to changes by providing mechanisms for flexible object composition.
* Reusability: They promote code reuse by encapsulating common object composition patterns.
* Maintainability: They improve the maintainability of your code by making it easier to understand and modify.

## Common Structural Patterns:

1. Adapter: Converts the interface of a class into another interface that clients expect.
2. Bridge: Decouples an abstraction from its implementation so that the two can vary independently.
3. Composite: Composes objects into tree structures to represent part-whole hierarchies.   
4. Decorator: Attaches additional responsibilities to an object dynamically.
5. Facade: Provides a unified interface to a set of interfaces in a subsystem.   
6. Flyweight: Reduces the number of objects created by sharing common data among multiple objects.
7. Proxy: Provides a surrogate or placeholder for another object to control access to it.

## When to Use Structural Patterns:

* When you need to improve the flexibility, reusability, or maintainability of your code.
* When you want to decouple objects from each other.
* When you need to create complex object structures.
* When you want to optimize performance by reducing the number of objects created.

## Benefits of Structural Patterns:

* Flexibility: Makes your code more adaptable to changes.
* Reusability: Promotes code reuse by encapsulating common object composition patterns.
* Maintainability: Improves the maintainability of your code by making it easier to understand and modify.
* Decoupling: Decouples objects from each other, making your code more modular and easier to test.
* Performance Optimization: Can improve performance by reducing the number of objects created.